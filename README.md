# YouTube Video Downloader V2 ALPHA
You know about this website called YouTube? Appearently it's pretty popular, idk. Point is, you know how you can watch videos via state-of-the-art internet technology? Here's my pitch, what if... you could watch videos without the internet! By downloading them. Well, it seems like YouTube already beat me to it, and made a convenient API. And then, [pytube](https://pypi.org/project/pytube) came along and made it even simpler to get a video downloaded. But you see... my video downloader goes one step further. Fun fact, YouTube videos aren't just a group of videos for every resolution. That would be far too convenient. Instead, every video is made up of a bunch of different *streams*, with multiple per resolution, that can all very in bitrate, file type, etc. And you want to know what the best part is? The highest bitrate versions (including the absolutely highest resolution versions) are made up of separate video and audio streams, which you have to stitch together. Small additional problem, the form of mp4 (the codec?) isn't always supported, even with applications like Microsoft's *own* video player (not out of the box, at least). Seeking an answer to all of this, I searched far and wide to figure out what a system environment variable is. But after that... I had [FFmpeg](https://ffmpeg.org) fully working. Armed with this power, all I had to do was write the user interaction part of the python script, and then figure out what FFmpeg was in the first place. But after that... after like an hour or two of effort, I successfully downloaded the highest-bitrate avaiable version of a video. All it took then was to spend way more hours improving the UI, and completely rewriting everything at one point... to get what you see in this repository today. Again, there are some more things I'd want to add to it, which I'll hopefully tackle relatively soon... but for now, it has all of the main features. To use it, simply figure out what FFmpeg is for yourself (or if you're on Linux, there's a good chance it's just... already installed... and the process is easier in case it isn't (Linux FTW!)), get Python working, get pytube installed, (it's a, do-it-yourself model, okay?), then throw "YouTubeVideoDownloaderV2 ALPHA.py" along with "UILibrary.py" into the same folder, and finally run the former script through the terminal if you want to download a video. In case you're interested, it does have a couple of options, which you can find at the top of the Python script, right below the imports. But um, yeah, that's about it!

# UILibrary
Ever asked the user for an integer, only to have your program crash because the user gave something that is not an integer? Well, this library is here to fix that! (As well as a bunch of other stuff). You can use the `ask` method for the problem mentioned above, use the `large_number_formatter` to turn "1000" into "1K", turn "314159265" seconds into "*1 year, 5 months, 9 weeks, 3 days, 2 hours, 27 minutes and 45 seconds*", run terminal commands, get terminal arguments; option lists, unique files, progress bars, clipboard without modules, there's a lot. And, I've added it all into this one library that has zero documentation. Enjoy!

# Input Recorder Ultimate
(Still a work-in-progrses, but all of the functionality is there from my limited testing.)
This python script can record your mouse movements/inputs, save them to a file, and play them back later. Why might you want that? Well, say you're playing a game like OpenRA, and always want different game options then what the defaults are. You're getting tired of clicking the *same* buttons, toggling and changing the *same* settings every single time. *If only there was a way to get a python script to click these buttons for me...* you might think. Well, that's what I was thinking. So I wrote that python script! It uses the module [Pynput](https://pypi.org/project/pynput) to record all of your mouse inputs, play them back, as well as save/load them for later use. Even more, it offers "FastMode" (sounds marketable...), which forgoes those smooth mouse movements, and instead opts for instantly teleporting your mouse around, with constant, short delays in between. With this power, you'll be able to configure your OpenRA settings in under a second! And, yeah, that's pretty much it.

# PythonPoint
This is still a work in progress (me from the future, there's isn't much progress anymore), but it's supposed to do something kind of similar to what Microsoft PowerPoint and Google Slides do, but with a txt file, and it exports images. It's no where near as feature-rich compared to the aforementioned software, but I think that it's cool; it supports text, images, and variables. As a note, I included some fonts with the Python file, all of the fonts are from Google Fonts, and should be fine to use. Most use the SIL Open Fonts License, although Roboto is distributed under the Apache License Version 2, so keep all of these in mind. If you want any more fonts, you should be able to add them into the Fonts folder, and the If statements shoudld take care of the rest. Note, the If statements were designed with Google Fonts's format in mind, so, you could try to follow the naming scheme of all the other fonts if necessary.

# Image Cropping Tool
I started this as a fun quick project to make with my PyBook Engine... turned out, it wasn't quick. It was actually the most difficult programming project I've worked on. Anyway, in terms of what it does, it crops images. In terms of how to use it, you drag in an image, or paste one in with Ctrl-V (Windows and MacOS only). Then, you click and drag to make a selection. Then, you drag the corners/side/center to resize or move the selection. Then, you press Enter (technically Return) to save it, to the path listed in the options at the top of the file. Note, if the file already exists, it'll add a number at the end, and try again. So, no overwriting. More notes, you can use Shift and Ctrl to crop more precisely, and alt to mirror any adjustments. So, there, you can crop images!

# PyBookEngine
This is something I worked on mostly some time ago, although occasionally I might update it a bit. The way it's supposed to work is you interact with it, and it interacts with PyGame. Why might you want it? Well, it simplifies many aspects of making something with PyGame, by doing a lot of the work for you. For instance, it handles updating the screen all by itself. No more do you need to deal with the reduced performance of `pygame.display.flip`, nor the complexity of `pygame.display.update(`With all of those rects`)`. It'll do all of that for you. Similarly, if you close the application, it closes! (Which is in fact something you need to add in) And, it supports many handy features, including automatic conversion between Pillow images, image paths, to the normal pygame surfaces. It even has a built in drop shadow feature! Now, with all of that said, I don't work on it too much anymore, meaning that some features may be a bit underdeveloped, with other things not having been implemented at all. Although, it does have the origin on the bottom left, so, that's cool...
